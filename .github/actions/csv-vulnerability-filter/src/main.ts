import * as core from '@actions/core';
import { CsvRow, Thresholds } from './types';
import {
  parseCsv,
  filterAndSeparate,
  generateCsvString,
  generateMarkdown,
  writeOutputCsv,
  writeOutputMarkdown,
  calculateSeverityCounts,
  checkCountThresholds,
  isFixedVersionPresent,
} from './processing';

function parseIntInput(key: string, defaultValue: number): number {
  const input = core.getInput(key);
  if (input === null || input === undefined || input === '') {
    return defaultValue;
  }
  const value = parseInt(input, 10);
  if (Number.isNaN(value)) {
    core.warning(`Invalid integer input for ${key}: "${input}". Using default ${defaultValue}.`);
    return defaultValue;
  }
  return value;
}

function errorString(error: unknown): string {
  return error instanceof Error ? error.message : String(error);
}

async function run(): Promise<void> {
  try {
    // --- Get Inputs ---

    const primaryCsvPath = core.getInput('primary_csv_path', { required: true });
    const comparisonCsvPath = core.getInput('comparison_csv_path'); // Optional path
    const ignoreUnpatched = core.getBooleanInput('ignore_unpatched');
    const minSeverity = core.getInput('filter_min_severity');
    await core.group('Action Inputs', async () => {
      core.info(`Primary CSV Path: ${primaryCsvPath}`);
      core.info(`Comparison CSV Path: ${comparisonCsvPath || '(Not provided)'}`);
      core.info(`Ignore Unpatched: ${ignoreUnpatched}`);
      core.info(`Minimum Severity Filter: ${minSeverity || '(Not provided)'}`);
      core.info(`Critical Threshold: ${parseIntInput('critical_threshold', 0)}`);
      core.info(`High Threshold: ${parseIntInput('high_threshold', 0)}`);
      core.info(`Medium Threshold: ${parseIntInput('medium_threshold', 0)}`);
      core.info(`Low Threshold: ${parseIntInput('low_threshold', 0)}`);
    });
    // --- Parse Primary CSV ---
    let primaryData: CsvRow[] = [];
    try {
      primaryData = parseCsv(primaryCsvPath);
      core.info(`Successfully parsed primary CSV: ${primaryCsvPath} (${primaryData.length} rows)`);
    } catch (error) {
      core.setFailed(`Failed to parse primary CSV ${primaryCsvPath}: ${await errorString(error)}`);
      return;
    }

    // --- Handle Comparison CSV & Initial Filtering ---
    let comparisonData: CsvRow[] = [];
    let comparisonSkipped = false;
    let filtered: CsvRow[] = [];
    let removed: CsvRow[] = [];

    if (!comparisonCsvPath || !comparisonCsvPath.trim()) {
      core.info('Comparison CSV path not provided or empty. Skipping baseline comparison.');
      comparisonSkipped = true;
    } else {
      try {
        comparisonData = parseCsv(comparisonCsvPath);
        core.info(`Successfully parsed comparison CSV: ${comparisonCsvPath} (${comparisonData.length} rows)`);
      } catch (error) {
        core.warning(`Failed to parse comparison CSV ${comparisonCsvPath}. Skipping baseline comparison.`);
        core.warning(`Error: ${await errorString(error)}`);
        comparisonSkipped = true;
      }
    }

    if (comparisonSkipped) {
      filtered = primaryData;
      removed = [];
    } else {
      const filterResult = filterAndSeparate(primaryData, comparisonData);
      filtered = filterResult.filtered;
      removed = filterResult.removed;
      core.info(`Comparison filtering complete: ${filtered.length} findings remain after comparison, ${removed.length} removed.`);
    }

    // --- Apply "Ignore Unpatched" Filter (if enabled) ---
    if (ignoreUnpatched) {
      core.info("Input 'ignore-unpatched' is true. Filtering out findings without a fixed version...");
      const originalFilteredCount = filtered.length;
      filtered = filtered.filter(isFixedVersionPresent);
      const removedCount = originalFilteredCount - filtered.length;
      if (removedCount > 0) {
        core.info(`Removed ${removedCount} unpatched findings from the list.`);
      } else {
        core.info('No unpatched findings needed removal from the filtered list.');
      }
    }
    core.info(`Final count for threshold check and output: ${filtered.length} findings.`);

    // --- Apply Severity Filter (if enabled) ---
    if (minSeverity) {
      core.info(`Applying severity filter: ${minSeverity}`);
      const severityLevels = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFORMATIONAL'];
      const severityIndex = severityLevels.indexOf(minSeverity.toUpperCase());
      if (severityIndex === -1) {
        core.warning(`Invalid severity level "${minSeverity}". No filtering applied.`);
      } else {
        const prefilterLength = filtered.length;
        filtered = filtered.filter((row) => {
          const severity = row.Severity?.toUpperCase();
          return severityLevels.indexOf(severity) <= severityIndex;
        });
        const postfilterLength = filtered.length;
        const removedCount = prefilterLength - postfilterLength;
        if (removedCount > 0) {
          core.info(`Removed ${removedCount} findings below severity level "${minSeverity}".`);
        }
      }
    }

    // --- Generate Output CSV Strings ---
    const filteredCsvString = generateCsvString(filtered);
    const removedCsvString = generateCsvString(removed);

    // --- Write Output CSV Files ---
    const filteredCsvOutputPath = writeOutputCsv(filteredCsvString, 'filtered_results');
    const removedCsvOutputPath = writeOutputCsv(removedCsvString, 'removed_results');

    // --- Generate Output Markdown ---
    core.info('Generating Markdown reports...');
    let filteredMarkdown = generateMarkdown(filtered, primaryData);
    let removedMarkdown = generateMarkdown(removed);

    if (comparisonSkipped) {
      removedMarkdown = '## Ignored Vulnerability Findings\n\nComparison skipped (no comparison file or file unparsable).\n';
    } else if (removed.length === 0) {
      removedMarkdown = '## Ignored Vulnerability Findings \n\nNo findings were removed based on the comparison file.\n';
    }
    if (comparisonSkipped) {
      filteredMarkdown = filteredMarkdown.replace('## Vulnerability Findings', '## Vulnerability Findings (Primary Scan)');
    } else {
      filteredMarkdown = filteredMarkdown.replace('## Vulnerability Findings', '## Vulnerability Findings (Filtered)');
    }

    // --- Add Markdown to GitHub Job Summary ---
    if (process.env.GITHUB_STEP_SUMMARY) {
      core.info('Appending filtered results to GitHub Job Summary...');
      core.summary.addRaw(filteredMarkdown);
      await core.summary.write();
      core.info('Successfully wrote to GitHub Job Summary.');
    } else {
      core.info('GITHUB_STEP_SUMMARY environment variable not set. Skipping job summary update.');
    }

    // --- Write Output Markdown Files ---
    const filteredMarkdownOutputPath = writeOutputMarkdown(filteredMarkdown, 'filtered_results');
    const removedMarkdownOutputPath = writeOutputMarkdown(removedMarkdown, 'removed_results');

    // --- Check Thresholds ---
    core.info('Calculating severity counts for threshold check...');
    const filteredCounts = calculateSeverityCounts(filtered);
    const inputThresholds: Thresholds = {
      critical: parseIntInput('critical_threshold', 0),
      high: parseIntInput('high_threshold', 0),
      medium: parseIntInput('medium_threshold', 0),
      low: parseIntInput('low_threshold', 0),
    };
    const thresholdCheck = checkCountThresholds(filteredCounts, inputThresholds);
    const thresholdExceeded = thresholdCheck ? 1 : 0;

    // --- Set Outputs ---
    core.info('Setting action outputs...');
    core.setOutput('filtered_results_csv_path', filteredCsvOutputPath);
    core.setOutput('filtered_results_markdown', filteredMarkdownOutputPath);
    core.setOutput('filtered_count', filtered.length.toString());

    core.setOutput('removed_results_csv_path', removedCsvOutputPath);
    core.setOutput('removed_results_markdown', removedMarkdownOutputPath);
    core.setOutput('removed_count', removed.length.toString());

    core.setOutput('vulnerability_threshold_exceeded', thresholdExceeded.toString());

    // --- Optionally Fail Action ---
    if (thresholdExceeded) {
      core.info('Vulnerability count threshold exceeded based on final filtered results.');
    } else {
      core.info('--- Action Completed Successfully ---');
      core.info('Vulnerability thresholds not exceeded.');
    }
  } catch (error) {
    core.setFailed(`Action failed: ${errorString(error)}`);
    if (error instanceof Error && error.stack) {
      core.debug(error.stack);
    }
  }
}

run();
