import * as core from '@actions/core';
import {
    parseCsv,
    filterAndSeparate,
    generateCsvString,
    generateMarkdown,
    writeOutputCsv
} from './processing';

async function run(): Promise<void> {
    try {
        const primaryCsvPath = core.getInput('primary-csv-path', { required: true });
        const comparisonCsvPath = core.getInput('comparison-csv-path', { required: true });
        const cveColumn = core.getInput('cve-column-name', { required: true });
        const packageColumn = core.getInput('package-column-name', { required: true });

        core.info('Inputs received:');
        core.info(`  Primary CSV Path: ${primaryCsvPath}`);
        core.info(`  Comparison CSV Path: ${comparisonCsvPath}`);
        core.info(`  CVE Column: ${cveColumn}`);
        core.info(`  Package Column: ${packageColumn}`);


        const requiredColumns = [cveColumn, packageColumn];
        const primaryData = parseCsv(primaryCsvPath, requiredColumns);

        // If no comparison CSV is provided, or file cannot be read, just generate markdown for the primary CSV
        // TODO - also do this for if comparison CSV can't be parsed correctly?
        if (!comparisonCsvPath || comparisonCsvPath.trim() === '') {
            core.info('No comparison CSV provided. Skipping comparison.');
            const primaryMarkdown = generateMarkdown(primaryData, 'Primary CSV Data', cveColumn, packageColumn);
            core.setOutput('filtered-results-markdown', primaryMarkdown);
            core.setOutput('filtered-results-csv-path', primaryCsvPath);
            core.setOutput('filtered-count', primaryData.length.toString());
            core.info('Primary CSV processed without comparison.');
            return;
        }
        const comparisonData = parseCsv(comparisonCsvPath, requiredColumns);

        const { filtered, removed } = filterAndSeparate(
            primaryData,
            comparisonData,
            cveColumn,
            packageColumn
        );

        const filteredCsvString = generateCsvString(filtered);
        const removedCsvString = generateCsvString(removed);

        const filteredCsvOutputPath = writeOutputCsv(filteredCsvString, 'filtered_results');
        const removedCsvOutputPath = writeOutputCsv(removedCsvString, 'removed_results');

        const severityColumn = ['Severity', 'severity', 'Finding Severity'].find(col => primaryData[0]?.hasOwnProperty(col));
        const filteredMarkdown = generateMarkdown(filtered, 'Unique Vulnerabilities (Filtered)', cveColumn, packageColumn, severityColumn);
        const removedMarkdown = generateMarkdown(removed, 'Common Vulnerabilities (Removed / Baseline)', cveColumn, packageColumn, severityColumn);

        core.setOutput('filtered-results-csv-path', filteredCsvOutputPath);
        core.setOutput('filtered-results-markdown', filteredMarkdown);
        core.setOutput('filtered-count', filtered.length.toString());

        core.setOutput('removed-results-csv-path', removedCsvOutputPath);
        core.setOutput('removed-results-markdown', removedMarkdown);
        core.setOutput('removed-count', removed.length.toString());

        core.info('Action completed successfully.');

    } catch (error) {
        if (error instanceof Error) {
            core.setFailed(`Action failed: ${error.message}`);
            if (error.stack) {
                core.debug(error.stack); 
            }
        } else {
            core.setFailed(`Action failed with unknown error: ${error}`);
        }
    }
}

run();