import * as core from '@actions/core';
import { CsvRow, Thresholds } from './types';
import {
    parseCsv,
    filterAndSeparate,
    generateCsvString,
    generateMarkdown,
    writeOutputCsv,
    writeOutputMarkdown,
    calculateSeverityCounts,
    checkCountThresholds,
    isFixedVersionPresent
} from './processing';

function parseIntInput(key: string, defaultValue: number): number {
    const input = core.getInput(key);
    if (input === null || input === undefined || input === '') {
        return defaultValue;
    }
    const value = parseInt(input, 10);
    if (isNaN(value)) {
        core.warning(`Invalid integer input for ${key}: "${input}". Using default ${defaultValue}.`);
        return defaultValue;
    }
    return value;
}

async function errorString(error: unknown): Promise<string> {
    return error instanceof Error ? error.message : String(error)
}



async function run(): Promise<void> {
    try {
        // --- Get Inputs ---
        const primaryCsvPath = core.getInput('primary_csv_path', { required: true });
        const comparisonCsvPath = core.getInput('comparison_csv_path'); // Optional path
        const ignoreUnpatched = core.getBooleanInput('ignore_unpatched');
        const minSeverity = core.getInput('filter_min_severity');


        core.info('--- Action Inputs ---');
        core.info(`Primary CSV Path: ${primaryCsvPath}`);
        core.info(`Comparison CSV Path: ${comparisonCsvPath || '(Not provided)'}`);
        core.info(`Ignore Unpatched: ${ignoreUnpatched}`);
        core.info("Assuming fixed CSV column names (vuln_id, severity, package_name, fixed_ver, etc.)");
        core.info('--- Starting Action ---');


        // --- Parse Primary CSV ---
        // Define ALL assumed column names required by filtering OR markdown OR ignore-unpatched
        const assumedRequiredColumns = [
            'vuln_id',          // Filtering key, Table ID
            'package_name',     // Filtering key, Table PURL Name
            'severity',         // Thresholds, Table Severity
            'fixed_ver',        // Ignore Unpatched, Table Fixed Package
            // Additional columns for the Markdown table
            'severity_provider',
            'cvss_score',
            'installed_ver',    // Table PURL Version
            'pkg_path',
            'epss_score',
            'exploit_available',
            'exploit_last_seen',
            'cwes',
        ];
        // Remove duplicates for the validation check
        const uniqueRequiredColumns = [...new Set(assumedRequiredColumns)];

        let primaryData: CsvRow[] = [];
        try {
            primaryData = parseCsv(primaryCsvPath);
            core.info(`Successfully parsed primary CSV: ${primaryCsvPath} (${primaryData.length} rows)`);
        } catch (error) {
             // If primary CSV fails, we cannot proceed
            core.setFailed(`Failed to parse primary CSV ${primaryCsvPath}: ${errorString(error)}`);
            return;
        }

        // --- Handle Comparison CSV & Initial Filtering ---
        let comparisonData: CsvRow[] = [];
        let comparisonSkipped = false;
        let filtered: CsvRow[] = [];
        let removed: CsvRow[] = [];

        if (!comparisonCsvPath || !comparisonCsvPath.trim()) {
            core.info('Comparison CSV path not provided or empty. Skipping baseline comparison.');
            comparisonSkipped = true;
        } else {
            try {
                // Validate required columns needed *just for filtering* in comparison CSV
                const comparisonRequiredCols = ['vuln_id', 'package_name'];
                comparisonData = parseCsv(comparisonCsvPath);
                core.info(`Successfully parsed comparison CSV: ${comparisonCsvPath} (${comparisonData.length} rows)`);
            } catch (error) {
                core.warning(`Failed to parse comparison CSV ${comparisonCsvPath}. Skipping baseline comparison.`);
                core.warning(`Error: ${errorString(error)}`);
                comparisonSkipped = true;
                // comparisonData remains []
            }
        }

        // Assign initial filtered/removed lists based on comparison outcome
        if (comparisonSkipped) {
            filtered = primaryData; // Start with all primary data
            removed = [];          // No data removed by comparison
        } else {
            // Perform the actual filtering using simplified logic
            const filterResult = filterAndSeparate(primaryData, comparisonData);
            filtered = filterResult.filtered;
            removed = filterResult.removed;
            core.info(`Comparison filtering complete: ${filtered.length} findings remain after comparison, ${removed.length} removed.`);
        }

        // --- Apply "Ignore Unpatched" Filter (if enabled) ---
        if (ignoreUnpatched) {
            core.info("Input 'ignore-unpatched' is true. Filtering out findings without a fixed version...");
            const originalFilteredCount = filtered.length;
            // isFixedVersionPresent assumes 'fixed_ver' column
            filtered = filtered.filter(isFixedVersionPresent);
            const removedCount = originalFilteredCount - filtered.length;
            if (removedCount > 0) {
                core.info(`Removed ${removedCount} unpatched findings from the list.`);
            } else {
                 core.info(`No unpatched findings needed removal from the filtered list.`);
            }
        }
        core.info(`Final count for threshold check and output: ${filtered.length} findings.`);

        // --- Apply Severity Filter (if enabled) ---
        if (minSeverity) {
            core.info(`Applying severity filter: ${minSeverity}`);
            const severityLevels = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFORMATIONAL'];
            const severityIndex = severityLevels.indexOf(minSeverity.toUpperCase());
            if (severityIndex === -1) {
                core.warning(`Invalid severity level "${minSeverity}". No filtering applied.`);
            } else {
                const prefilterLength = filtered.length;
                filtered = filtered.filter(row => {
                    const severity = row['severity']?.toUpperCase();
                    return severityLevels.indexOf(severity) >= severityIndex;
                });
                const postfilterLength = filtered.length;
                const removedCount = prefilterLength - postfilterLength;
                if (removedCount > 0) {
                    core.info(`Removed ${removedCount} findings below severity level "${minSeverity}".`);
                }
            }
        }


        // --- Generate Output CSV Strings ---
        const filteredCsvString = generateCsvString(filtered);
        const removedCsvString = generateCsvString(removed);

        // --- Write Output CSV Files ---
        const filteredCsvOutputPath = writeOutputCsv(filteredCsvString, 'filtered_results');
        const removedCsvOutputPath = writeOutputCsv(removedCsvString, 'removed_results');

        // --- Generate Output Markdown ---
        core.info('Generating Markdown reports...');
        let filteredMarkdown = generateMarkdown(filtered, primaryData); // Generates table for FINAL filtered items
        let removedMarkdown = generateMarkdown(removed);   // Generates table for items removed by comparison

        // Adjust 'removed' markdown if comparison was skipped
        if (comparisonSkipped) {
             removedMarkdown = `## Vulnerability Findings (Removed by Comparison)\n\nBaseline comparison was skipped (no comparison file provided or file was unparsable).\n`;
        } else if (removed.length === 0) {
             removedMarkdown = `## Vulnerability Findings (Removed by Comparison)\n\nNo findings were removed based on the comparison file.\n`;
        }
         // Adjust 'filtered' title slightly for clarity if comparison was skipped
        if (comparisonSkipped) {
            filteredMarkdown = filteredMarkdown.replace('## Vulnerability Findings', '## Vulnerability Findings (Primary Scan)');
        } else {
             filteredMarkdown = filteredMarkdown.replace('## Vulnerability Findings', '## Vulnerability Findings (Filtered)');
        }

        // --- Add Markdown to GitHub Job Summary ---
        if (process.env.GITHUB_STEP_SUMMARY) {
            core.info('Appending filtered results to GitHub Job Summary...');
            core.summary.addRaw(filteredMarkdown); // Add the entire generated markdown
            //core.summary.addSeparator(); // Optional: Add a separator between reports
            //core.summary.addRaw(removedMarkdown);  // Add the entire generated markdown
            await core.summary.write(); // Asynchronously writes to the GITHUB_STEP_SUMMARY file
            core.info('Successfully wrote to GitHub Job Summary.');
        } else {
            core.info('GITHUB_STEP_SUMMARY environment variable not set. Skipping job summary update.');
        }

        // --- Write Output Markdown Files ---
        const filteredMarkdownOutputPath = writeOutputMarkdown(filteredMarkdown, 'filtered_results');
        const removedMarkdownOutputPath = writeOutputMarkdown(removedMarkdown, 'removed_results');

        // --- Check Thresholds ---
        core.info('Calculating severity counts for threshold check...');
        // Calculate counts on the FINAL 'filtered' list (after ignore-unpatched)
        const filteredCounts = calculateSeverityCounts(filtered); // Assumes 'severity' column
        
        // Always show thresholds as being exceeded - we always want to show results
        const thresholdExceeded = 1 //checkCountThresholds(filteredCounts); // Checks against thresholds

        // --- Set Outputs ---
        core.info('Setting action outputs...');
        core.setOutput('filtered_results_csv_path', filteredCsvOutputPath);
        core.setOutput('filtered_results_markdown', filteredMarkdownOutputPath);
        core.setOutput('filtered_count', filtered.length.toString()); // Count AFTER ignore-unpatched

        core.setOutput('removed_results_csv_path', removedCsvOutputPath);
        core.setOutput('removed_results_markdown', removedMarkdownOutputPath);
        core.setOutput('removed_count', removed.length.toString());

        core.setOutput('vulnerability_threshold_exceeded', thresholdExceeded.toString());

        // ---  Optionally Fail Action ---
        if (thresholdExceeded) {
            // Specific warning/error logged within checkCountThresholds
            core.info('Vulnerability count threshold exceeded based on final filtered results.');
        } else {
            core.info('--- Action Completed Successfully ---');
            core.info('Vulnerability thresholds not exceeded.');
        }

    } catch (error) {
        core.setFailed(`Action failed: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error && error.stack) {
             core.debug(error.stack);
        }
    }
}

run();