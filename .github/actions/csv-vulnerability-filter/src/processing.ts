// .github/actions/csv-vulnerability-filter/src/processing.ts
import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import Papa from 'papaparse';
import { CsvRow, FilterResult } from './types';

/**
 * Reads and parses a CSV file.
 * @param filePath Path to the CSV file.
 * @param requiredColumns Array of column names expected to exist.
 * @returns Array of row objects.
 */
export function parseCsv(filePath: string, requiredColumns: string[]): CsvRow[] {
    core.info(`Reading CSV file: ${filePath}`);
    if (!fs.existsSync(filePath)) {
        throw new Error(`CSV file not found at path: ${filePath}`);
    }
    const csvContent = fs.readFileSync(filePath, 'utf8');

    const parseResult = Papa.parse<CsvRow>(csvContent.trim(), {
        header: true, // Crucial: Treat first row as header
        skipEmptyLines: true,
        dynamicTyping: false, // Keep all as strings for consistency initially
    });

    if (parseResult.errors.length > 0) {
        core.warning(`CSV parsing encountered errors in ${filePath}:`);
        parseResult.errors.forEach(err => core.warning(`  - ${err.message} (Row: ${err.row})`));
        // Decide if errors are fatal - for now, proceed if data exists
    }

    if (!parseResult.data || parseResult.data.length === 0) {
        core.warning(`CSV file ${filePath} is empty or contains no data after header.`);
        return [];
    }

    // Validate required columns exist in the parsed headers
    const headers = parseResult.meta.fields;
    if (!headers) {
        throw new Error(`Could not extract headers from CSV: ${filePath}`);
    }
    for (const col of requiredColumns) {
        if (!headers.includes(col)) {
            throw new Error(`Required column "${col}" not found in CSV headers of ${filePath}. Found headers: ${headers.join(', ')}`);
        }
    }

    core.info(`Successfully parsed ${parseResult.data.length} rows from ${filePath}.`);
    return parseResult.data;
}

/**
 * Creates a unique key for filtering based on specified columns.
 * Handles potential missing values gracefully. Converts to lowercase.
 */
function createFilteringKey(row: CsvRow, cveColumn: string, packageColumn: string): string {
    const cve = row[cveColumn] ?? 'unknown_cve';
    const pkg = row[packageColumn] ?? 'unknown_package';
    return `${cve}-${pkg}`.toLowerCase();
}

/**
 * Filters primary data against comparison data.
 * @param primaryData Parsed data from the primary CSV.
 * @param comparisonData Parsed data from the comparison CSV.
 * @param cveColumn Name of the CVE column.
 * @param packageColumn Name of the package column.
 * @returns An object containing arrays of filtered and removed rows.
 */
export function filterAndSeparate(
    primaryData: CsvRow[],
    comparisonData: CsvRow[],
    cveColumn: string,
    packageColumn: string
): FilterResult {
    core.info(`Filtering ${primaryData.length} primary entries against ${comparisonData.length} comparison entries.`);
    core.info(`Using columns: CVE='${cveColumn}', Package='${packageColumn}'`);

    const comparisonKeys = new Set(
        comparisonData.map(row => createFilteringKey(row, cveColumn, packageColumn))
    );
    core.debug(`Created comparison key set with ${comparisonKeys.size} unique keys.`);

    const result: FilterResult = {
        filtered: [],
        removed: [],
    };

    primaryData.forEach(row => {
        const key = createFilteringKey(row, cveColumn, packageColumn);
        if (comparisonKeys.has(key)) {
            // This vulnerability is in the baseline, mark as removed
            result.removed.push(row);
        } else {
            // This vulnerability is unique to the primary scan
            result.filtered.push(row);
        }
    });

    core.info(`Filtering complete: ${result.filtered.length} unique findings, ${result.removed.length} common/removed findings.`);
    return result;
}

/**
 * Generates a CSV string from an array of row objects.
 * @param data Array of row objects.
 * @returns CSV formatted string.
 */
export function generateCsvString(data: CsvRow[]): string {
    if (data.length === 0) {
        return ''; // Return empty string if no data
    }
    // PapaParse unparse automatically determines headers from the keys of the first object
    try {
        const csvString = Papa.unparse(data, {
            header: true,
        });
        return csvString;
    } catch (error) {
        core.error(`Failed to generate CSV string: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error('CSV string generation failed.');
    }
}

/**
 * Generates a simple Markdown summary.
 * @param data Array of row objects to summarize.
 * @param title Title for the Markdown section.
 * @param cveColumn Name of the CVE column for display.
 * @param packageColumn Name of the package column for display.
 * @param severityColumn Optional: Name of severity column for display.
 * @returns Markdown formatted string.
 */
export function generateMarkdown(
    data: CsvRow[],
    title: string,
    cveColumn: string,
    packageColumn: string,
    severityColumn?: string // Allow optional severity display
): string {
    let markdown = `### ${title}\n\n`;
    markdown += `**Total Count:** ${data.length}\n\n`;

    if (data.length > 0) {
        markdown += `| ${severityColumn ? 'Severity | ' : ''} ${cveColumn} | ${packageColumn} |\n`;
        markdown += `| ${severityColumn ? '--- | ' : ''}--- | --- |\n`;
        // Display top 10 or fewer
        data.slice(0, 10).forEach(row => {
            const severity = severityColumn ? (row[severityColumn] ?? 'N/A') + ' | ' : '';
            const cve = row[cveColumn] ?? 'N/A';
            const pkg = row[packageColumn] ?? 'N/A';
            markdown += `| ${severity}${cve} | ${pkg} |\n`;
        });
        if (data.length > 10) {
            markdown += `\n... and ${data.length - 10} more.\n`;
        }
    }

    return markdown;
}

/**
 * Writes data to a CSV file in the runner's temp directory.
 * @param csvString The CSV content to write.
 * @param baseFilename Suggested base filename (e.g., 'filtered_results').
 * @returns The full path to the written file.
 */
export function writeOutputCsv(csvString: string, baseFilename: string): string {
    // Ensure runner temp directory exists (it should)
    const tempDir = process.env.RUNNER_TEMP;
    if (!tempDir) {
        throw new Error("Runner temporary directory (RUNNER_TEMP) is not defined.");
    }
    // Create a unique filename
    const uniqueId = Math.random().toString(36).substring(2, 8);
    const filename = `${baseFilename}_${uniqueId}.csv`;
    const outputPath = path.join(tempDir, filename);

    core.info(`Writing output CSV to: ${outputPath}`);
    try {
        fs.writeFileSync(outputPath, csvString, 'utf8');
        return outputPath;
    } catch (error) {
        core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error('Failed to write output CSV.');
    }
}