// .github/actions/csv-vulnerability-filter/src/processing.ts
import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import Papa from 'papaparse';
import { CsvRow, FilterResult, SeverityCounts, Thresholds } from './types';

/**
 * Reads and parses a CSV file, validating required columns.
 * @param filePath Path to the CSV file.
 * @param requiredColumns Array of column names expected to exist.
 * @returns Array of row objects.
 * @throws Error if file not found or required column is missing.
 */
export function parseCsv(filePath: string, requiredColumns: string[]): CsvRow[] {
    core.debug(`Attempting to read CSV file: ${filePath}`);
    if (!fs.existsSync(filePath)) {
        throw new Error(`CSV file not found at path: ${filePath}`);
    }
    const csvContent = fs.readFileSync(filePath, 'utf8');

    // Check if file content is empty
    if (!csvContent || csvContent.trim() === '') {
        core.info(`CSV file ${filePath} is empty.`);
        return [];
    }

    // Split content into lines, handling both \n and \r\n
    const lines = csvContent.split(/\r?\n/);

    // --- ADDED DEBUG LOGGING FOR FIRST THREE LINES ---
    core.info(`--- Start: First 3 lines of ${filePath} ---`);
    for (let i = 0; i < Math.min(3, lines.length); i++) {
        core.info(`Original Line ${i + 1}: ${lines[i]}`);
    }
    core.info(`--- End: First 3 lines of ${filePath} ---`);
    // --- END OF DEBUG LOGGING ---

    // Check if there's at least a header line after removing the metadata line
    if (lines.length <= 1) {
        core.info(`CSV file ${filePath} contains only metadata line or is empty after splitting. No data to parse.`);
        return [];
    }

    // AWS Inspector Headings, for reference: "ID","Severity","CVSS","Installed Package","Fixed Package","Path","EPSS","Exploit Available","Exploit Last Seen","CWEs"

    // Skip the first two lines of metadata. Header is the third line
    const contentWithoutFirstLine = lines.slice(2).join('\n');

    const parseResult = Papa.parse<CsvRow>(contentWithoutFirstLine, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false, // Keep all as strings initially
    });

    if (parseResult.errors.length > 0) {
        core.warning(`CSV parsing encountered errors in ${filePath}:`);
        // Log only the first few errors to avoid excessive logging
        parseResult.errors.slice(0, 5).forEach(err => core.warning(`  - ${err.message} (Row: ${err.row})`));
        if (parseResult.errors.length > 5) {
            core.warning(`  ... and ${parseResult.errors.length - 5} more errors.`);
        }
        // Proceed even with errors if some data was parsed
    }

    if (!parseResult.data || parseResult.data.length === 0) {
        // This might be okay if the file is genuinely empty, log as info
        core.info(`CSV file ${filePath} is empty or contains no data rows.`);
        return [];
    }

    const headers = parseResult.meta.fields;
    if (!headers) {
        throw new Error(`Could not extract headers from CSV (after skipping first line): ${filePath}. Check file format.`);
    }
    core.info(`CSV Headers found in ${filePath} (after skipping first line): ${headers.join(', ')}`);


    core.debug(`Successfully parsed ${parseResult.data.length} data rows from ${filePath}.`);
    return parseResult.data;
}


/**
 * Creates a unique key for filtering using assumed fixed column names 'vuln_id' and 'package_name'.
 * Returns null if key cannot be formed (e.g., missing required fields).
 */
function createFilteringKey(row: CsvRow): string | null {
    return `${row['ID']}`;
    //const vulnId = `${row['ID']}`; // Assumed column name

    // const pkg = row['package_name']; // Assumed column name

    // // Both vuln_id and package_name need to be present for a meaningful key
    // if (!pkg || !pkg.trim()) {
    //     core.debug(`Skipping filtering key generation due to missing 'package_name': ${JSON.stringify(row)}`);
    //     return null;
    // }
    // if (!vulnId || !vulnId.trim()) {
    //     // If vuln_id is missing, we cannot reliably compare, treat as unique
    //     core.debug(`Skipping filtering key generation due to missing 'vuln_id': ${JSON.stringify(row)}`);
    //     return null;
    // }

    // const cleanPkg = pkg.trim().toLowerCase();
    // const cleanVulnId = vulnId.trim().toLowerCase();

    // // Simplified key based on assumption
    // return `${cleanVulnId}-${cleanPkg}`;
}

/**
 * Filters primary data against comparison data using assumed fixed column names.
 */
export function filterAndSeparate(
    primaryData: CsvRow[],
    comparisonData: CsvRow[]
): FilterResult {
    core.info(`Filtering ${primaryData.length} primary entries against ${comparisonData.length} comparison entries using assumed columns ('vuln_id', 'package_name').`);

    const comparisonKeys = new Set<string>();
    comparisonData.forEach(row => {
        const key = createFilteringKey(row); // Uses hardcoded names internally
        if (key !== null) {
            comparisonKeys.add(key);
        }
    });

    core.debug(`Created comparison key set with ${comparisonKeys.size} unique valid keys.`);

    const result: FilterResult = { filtered: [], removed: [] };
    primaryData.forEach(row => {
        const key = createFilteringKey(row);
        // If key is null (cannot identify uniquely) OR key is not in comparison set, keep it.
        if (key === null || !comparisonKeys.has(key)) {
            result.filtered.push(row);
        } else {
            // Key is valid AND present in comparison set, remove it.
            result.removed.push(row);
        }
    });

    core.debug(`Filtering comparison complete: ${result.filtered.length} findings remain, ${result.removed.length} removed.`);
    return result;
}

/**
 * Calculates severity counts using the assumed 'severity' column.
 */
export function calculateSeverityCounts(data: CsvRow[]): SeverityCounts {
    const severityColumn = 'Severity'; // Assumed column name
    const counts: SeverityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFORMATIONAL: 0, UNDEFINED: 0 };

    for (const row of data) {
        // Standardize checks against uppercase
        const severity = (row[severityColumn]?.trim() || 'UNDEFINED').toUpperCase();
        switch (severity) {
            case 'CRITICAL': counts.CRITICAL++; break;
            case 'HIGH': counts.HIGH++; break;
            case 'MEDIUM': counts.MEDIUM++; break;
            case 'LOW': counts.LOW++; break;
            case 'INFORMATIONAL': case 'INFO': counts.INFORMATIONAL++; break;
            default: counts.UNDEFINED++; break;
        }
    }
    core.debug(`Calculated counts (assuming 'Severity' column): ${JSON.stringify(counts)}`);
    return counts;
}

/**
 * Checks if calculated counts exceed the defined thresholds.
 */
export function checkCountThresholds(counts: SeverityCounts, thresholds: Thresholds): boolean {
    let exceeded = false;
    core.info('Checking vulnerability count thresholds...');

    // Check each level only if its threshold is enabled (>= 0)
    if (thresholds.critical >= 0 && counts.CRITICAL > thresholds.critical) {
        core.warning(`Threshold exceeded: ${counts.CRITICAL} CRITICAL vulnerabilities found (limit: ${thresholds.critical}).`);
        exceeded = true;
    } else if (thresholds.critical >= 0) {
        core.info(`CRITICAL vulnerability count (${counts.CRITICAL}) within limit (${thresholds.critical}).`);
    }

    if (thresholds.high >= 0 && counts.HIGH > thresholds.high) {
        core.warning(`Threshold exceeded: ${counts.HIGH} HIGH vulnerabilities found (limit: ${thresholds.high}).`);
        exceeded = true;
    } else if (thresholds.high >= 0) {
        core.info(`HIGH vulnerability count (${counts.HIGH}) within limit (${thresholds.high}).`);
    }

    if (thresholds.medium >= 0 && counts.MEDIUM > thresholds.medium) {
        core.warning(`Threshold exceeded: ${counts.MEDIUM} MEDIUM vulnerabilities found (limit: ${thresholds.medium}).`);
        exceeded = true;
    } else if (thresholds.medium >= 0) {
        core.info(`MEDIUM vulnerability count (${counts.MEDIUM}) within limit (${thresholds.medium}).`);
    }

    if (thresholds.low >= 0 && counts.LOW > thresholds.low) {
        core.warning(`Threshold exceeded: ${counts.LOW} LOW vulnerabilities found (limit: ${thresholds.low}).`);
        exceeded = true;
    } else if (thresholds.low >= 0) {
        core.info(`LOW vulnerability count (${counts.LOW}) within limit (${thresholds.low}).`);
    }

    // Log final status
    if (!exceeded) {
        core.info('All vulnerability counts are within defined thresholds.');
    } else {
        core.info('One or more vulnerability count thresholds were exceeded.');
    }
    return exceeded;
}

/**
 * Checks if the value in the assumed 'fixed_ver' column indicates a fix is available.
 * Returns true if a seemingly valid fix version is present, false otherwise.
 */
export function isFixedVersionPresent(row: CsvRow): boolean {
    const fixedVer = row['Fixed Package'];
    if (!fixedVer) return false; // Handles null, undefined
    const trimmed = fixedVer.trim().toUpperCase();
    // Add any other known "no fix" indicators if necessary
    return trimmed !== '' && trimmed !== 'N/A' && trimmed !== 'NONE' && !trimmed.startsWith('NO_FIX');
}

/**
 * Generates a CSV string from an array of row objects.
 */
export function generateCsvString(data: CsvRow[]): string {
    if (data.length === 0) {
        return ''; // Return empty string if no data
    }
    try {
        const csvString = Papa.unparse(data, {
            header: true, // Include header row based on keys of first object
        });
        return csvString;
    } catch (error) {
        core.error(`Failed to generate CSV string: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error('CSV string generation failed.');
    }
}

/**
 * Writes data to a CSV file in the runner's temp directory.
 */
export function writeOutputCsv(csvString: string, baseFilename: string): string {
    const tempDir = process.env.RUNNER_TEMP;
    if (!tempDir) {
        // Fallback or error if runner temp is not available
        core.warning("RUNNER_TEMP environment variable not defined. Using current directory for output.");
        const fallbackPath = path.resolve('.'); // Use current directory
         // Ensure unique filename even in fallback
        const uniqueId = Math.random().toString(36).substring(2, 8);
        const filename = `${baseFilename}_${uniqueId}.csv`;
        const outputPath = path.join(fallbackPath, filename);
        core.info(`Writing output CSV to fallback location: ${outputPath}`);
         try {
            fs.writeFileSync(outputPath, csvString, 'utf8');
            return outputPath;
        } catch (error) {
            core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
            throw new Error(`Failed to write output CSV to fallback location: ${outputPath}`);
        }
    }

    // Ensure unique filename in runner temp
    const uniqueId = Math.random().toString(36).substring(2, 8);
    const filename = `${baseFilename}_${uniqueId}.csv`;
    const outputPath = path.join(tempDir, filename);

    core.info(`Writing output CSV to: ${outputPath}`);
    try {
        fs.writeFileSync(outputPath, csvString, 'utf8');
        return outputPath;
    } catch (error) {
        core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to write output CSV: ${outputPath}`);
    }
}

// Helper to clean cell data for Markdown table
function cleanCell(value: string | undefined | null, defaultValue = ''): string {
    // Replace pipes (|), backticks (`), and newlines to avoid breaking Markdown table structure
    // Trim whitespace
    return value?.trim().replace(/\|/g, '\\|').replace(/`/g, '\\`').replace(/\r?\n|\r/g, ' ') || defaultValue;
}

// Helper to format PURL (uses assumed column names)
function formatPurl(pkgName: string | undefined | null, pkgVersion: string | undefined | null): string {
    const cleanPkg = cleanCell(pkgName);
    const cleanVer = cleanCell(pkgVersion);
    if (!cleanPkg || !cleanVer) return '';
    // Basic PURL format - Needs refinement for package types (npm, maven, etc.)
    // Consider adding another assumed column like 'package_manager' if available in CSV
    // For now, just represent as code block:
    return `\`${cleanPkg}@${cleanVer}\``;
}

/**
 * Generates a detailed Markdown vulnerability table assuming fixed column names,
 * matching the format from the create_vulnerability_details_table Python function.
 * @param data The array of vulnerability data (CsvRow objects).
 * @returns Markdown formatted string.
 */
export function generateMarkdown(data: CsvRow[]): string {
    const title = "Vulnerability Findings"; // Fixed title matching Python function's scope
    core.info(`Generating detailed Markdown table "${title}" for ${data.length} items (assuming fixed column names).`);

    if (data.length === 0) {
        return `## ${title}\n\nNo findings to display.\n`;
    }

    let markdown = `## ${title}\n\n`;

    // Define Header Row exactly as in Python (including Markdown links)
    const headerColumns = [
        "ID",                             // Assumes 'vuln_id'
        "Severity",                       // Assumes 'severity'
        "Source",                         // Assumes 'severity_provider'
        "[CVSS](https://www.first.org/cvss/)", // Assumes 'cvss_score'
        "Installed Package ([PURL](https://github.com/package-url/purl-spec/tree/master?tab=readme-ov-file#purl))", // Assumes 'package_name', 'installed_ver'
        "Fixed Package",                  // Assumes 'fixed_ver'
        "Path",                           // Assumes 'pkg_path'
        "[EPSS](https://www.first.org/epss/)",   // Assumes 'epss_score'
        "Exploit Available",              // Assumes 'exploit_available'
        "Exploit Last Seen",              // Assumes 'exploit_last_seen'
        "CWEs",                           // Assumes 'cwes'
    ];
    const headerRow = `| ${headerColumns.join(' | ')} |`;
    // Generate separator based on the number of columns
    const separatorRow = `| ${headerColumns.map(() => '---').join(' | ')} |`;

    const tableRows: string[] = [headerRow, separatorRow];

    // Sort data by CVSS score (descending) - uses assumed 'cvss_score' column
    const sortedData = [...data].sort((a, b) => {
        const scoreA = parseFloat(a['cvss_score'] || '-1'); // Assumed name
        const scoreB = parseFloat(b['cvss_score'] || '-1'); // Assumed name
        const validScoreA = isNaN(scoreA) ? -1 : scoreA;
        const validScoreB = isNaN(scoreB) ? -1 : scoreB;
        return validScoreB - validScoreA; // Descending sort
    });

    // Generate Data Rows using assumed fixed column names
    sortedData.forEach(row => {
        const installedPackagePurl = formatPurl(row['package_name'], row['installed_ver']); // Assumed names

        const cells = [
            cleanCell(row['vuln_id']),           // Assumed name
            cleanCell(row['severity']),         // Assumed name
            cleanCell(row['severity_provider']),// Assumed name
            cleanCell(row['cvss_score']),       // Assumed name
            installedPackagePurl,
            cleanCell(row['fixed_ver']),        // Assumed name
            cleanCell(row['pkg_path']),         // Assumed name
            cleanCell(row['epss_score']),       // Assumed name
            cleanCell(row['exploit_available']),// Assumed name
            cleanCell(row['exploit_last_seen']),// Assumed name
            cleanCell(row['cwes']),             // Assumed name
        ];
        tableRows.push(`| ${cells.join(' | ')} |`);
    });

    markdown += tableRows.join('\n');
    return markdown;
}

// Export necessary functions for main.ts
export { cleanCell, formatPurl };