import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import Papa from 'papaparse';
import { CsvRow, FilterResult, SeverityCounts, Thresholds } from './types';

const AWS_INSPECTOR_HEADER_COLUMNS = [
  "ID",
  "Severity",
  "CVSS",
  "Installed Package",
  "Fixed Package",
  "Path",
  "EPSS",
  "Exploit Available",
  "Exploit Last Seen",
  "CWEs"
];

export function parseCsv(filePath: string): CsvRow[] {
  core.debug(`Attempting to read CSV file: ${filePath}`);
  if (!fs.existsSync(filePath)) {
    throw new Error(`CSV file not found at path: ${filePath}`);
  }
  const csvContent = fs.readFileSync(filePath, 'utf8');

  // Check if file content is empty
  if (!csvContent || csvContent.trim() === '') {
    core.info(`CSV file ${filePath} is empty.`);
    return [];
  }

  // Split content into lines, handling both \n and \r\n
  const lines = csvContent.split(/\r?\n/);

  // Check if there's at least a header line after removing the metadata line
  if (lines.length <= 3) {
    core.info(`CSV file ${filePath} contains only metadata line or is empty after splitting. No data to parse.`);
    return [];
  }

  // Skip the first two lines of metadata. Header is the third line
  const contentWithoutFirstLine = lines.slice(2).join('\n');

  const parseResult = Papa.parse<CsvRow>(contentWithoutFirstLine, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: false, // Keep all as strings initially
  });

  if (parseResult.errors.length > 0) {
    core.warning(`CSV parsing encountered errors in ${filePath}:`);
    parseResult.errors.slice(0, 5).forEach(err => core.warning(`  - ${err.message} (Row: ${err.row})`));
    if (parseResult.errors.length > 5) {
      core.warning(`  ... and ${parseResult.errors.length - 5} more errors.`);
    }
  }

  if (!parseResult.data || parseResult.data.length === 0) {
    core.info(`CSV file ${filePath} is empty or contains no data rows.`);
    return [];
  }

  const headers = parseResult.meta.fields;
  if (!headers) {
    throw new Error(`Could not extract headers from CSV (after skipping first line): ${filePath}. Check file format.`);
  }
  core.info(`CSV Headers found in ${filePath} (after skipping first line): ${headers.join(', ')}`);

  core.debug(`Successfully parsed ${parseResult.data.length} data rows from ${filePath}.`);
  return parseResult.data;
}

function createFilteringKey(row: CsvRow): string | null {
  return row['ID'];
}

export function filterAndSeparate(
  primaryData: CsvRow[],
  comparisonData: CsvRow[]
): FilterResult {
  core.info(`Filtering ${primaryData.length} primary entries against ${comparisonData.length} comparison entries using assumed columns ('vuln_id', 'package_name').`);

  const comparisonKeys = new Set<string>();
  comparisonData.forEach(row => {
    const key = createFilteringKey(row);
    if (key !== null) {
      comparisonKeys.add(key);
    }
  });

  core.debug(`Created comparison key set with ${comparisonKeys.size} unique valid keys.`);

  const result: FilterResult = { filtered: [], removed: [] };
  primaryData.forEach(row => {
    const key = createFilteringKey(row);
    if (key === null || !comparisonKeys.has(key)) {
      result.filtered.push(row);
    } else {
      result.removed.push(row);
    }
  });

  core.debug(`Filtering comparison complete: ${result.filtered.length} findings remain, ${result.removed.length} removed.`);
  return result;
}

export function calculateSeverityCounts(data: CsvRow[]): SeverityCounts {
  const severityColumn = 'Severity';
  const counts: SeverityCounts = { critical: 0, high: 0, medium: 0, low: 0, informational: 0, undefined: 0 };

  for (const row of data) {
    const severity = (row[severityColumn]?.trim() || 'undefined').toLowerCase();
    switch (severity) {
      case 'critical': counts.critical++; break;
      case 'high': counts.high++; break;
      case 'medium': counts.medium++; break;
      case 'low': counts.low++; break;
      case 'informational': counts.informational++; break;
      default: counts.undefined++; break;
    }
  }
  core.info(`Calculated counts (assuming 'Severity' column): ${JSON.stringify(counts)}`);
  return counts;
}

// export function checkCountThresholds(counts: SeverityCounts, thresholds: Thresholds): boolean {
//   let exceeded = false;
//   core.info('Checking vulnerability count thresholds...');

//   if (thresholds.critical >= 0 && counts.critical > thresholds.critical) {
//     core.error(`Threshold exceeded: ${counts.critical} critical vulnerabilities found (limit: ${thresholds.critical}).`);
//     exceeded = true;
//   } else if (thresholds.critical >= 0) {
//     core.info(`Critical vulnerability count (${counts.critical}) within limit (${thresholds.critical}).`);
//   }

//   if (thresholds.high >= 0 && counts.high > thresholds.high) {
//     core.error(`Threshold exceeded: ${counts.high} high vulnerabilities found (limit: ${thresholds.high}).`);
//     exceeded = true;
//   } else if (thresholds.high >= 0) {
//     core.info(`High vulnerability count (${counts.high}) within limit (${thresholds.high}).`);
//   }

//   if (thresholds.medium >= 0 && counts.medium > thresholds.medium) {
//     core.error(`Threshold exceeded: ${counts.medium} medium vulnerabilities found (limit: ${thresholds.medium}).`);
//     exceeded = true;
//   } else if (thresholds.medium >= 0) {
//     core.info(`Medium vulnerability count (${counts.medium}) within limit (${thresholds.medium}).`);
//   }

//   if (thresholds.low >= 0 && counts.low > thresholds.low) {
//     core.error(`Threshold exceeded: ${counts.low} low vulnerabilities found (limit: ${thresholds.low}).`);
//     exceeded = true;
//   } else if (thresholds.low >= 0) {
//     core.info(`Low vulnerability count (${counts.low}) within limit (${thresholds.low}).`);
//   }

//   if (!exceeded) {
//     core.info('All vulnerability counts are within defined thresholds.');
//   }
//   return exceeded;
// }

export function checkCountThresholds(counts: SeverityCounts, thresholds: Thresholds): boolean {
  core.info('Checking vulnerability count thresholds...');
  // using exceeded = exceeded || checkCountThreshold(...) to avoid setting exceeded to false once it is true
  let exceeded = checkCountThreshold(counts, thresholds.critical, 'critical');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.high, 'high');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.medium, 'medium');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.low, 'low');
  if (!exceeded) {
    core.info('All vulnerability counts are within defined thresholds.');
  }
  return exceeded;
}
function checkCountThreshold(counts: SeverityCounts, threshold: number, severity: keyof SeverityCounts): boolean {
  if (threshold >= 0 && counts[severity] > threshold) {
    core.warning(`Threshold exceeded: ${counts[severity]} ${severity} vulnerabilities found (limit: ${threshold}).`);
    return true;
  } else if (threshold >= 0) {
    core.info(`${severity.charAt(0).toUpperCase() + severity.slice(1)} vulnerability count (${counts[severity]}) within limit (${threshold}).`);
  }
  return false;
}

export function isFixedVersionPresent(row: CsvRow): boolean {
  const fixedVer = row['Fixed Package'];
  if (!fixedVer) return false;
  const trimmed = fixedVer.trim().toUpperCase();
  return trimmed !== '' && trimmed !== 'N/A' && trimmed !== 'NONE' && !trimmed.startsWith('NO_FIX');
}

export function generateCsvString(data: CsvRow[]): string {
  if (data.length === 0) {
    return '';
  }
  try {
    const csvString = Papa.unparse(data, {
      header: true,
    });
    return csvString;
  } catch (error) {
    core.error(`Failed to generate CSV string: ${error instanceof Error ? error.message : String(error)}`);
    throw new Error('CSV string generation failed.');
  }
}

export function writeOutputCsv(csvString: string, baseFilename: string): string {
  const tempDir = process.env.RUNNER_TEMP;
  if (!tempDir) {
    core.warning("RUNNER_TEMP environment variable not defined. Using current directory for output.");
    const fallbackPath = path.resolve('.');
    const uniqueId = Math.random().toString(36).substring(2, 8);
    const filename = `${baseFilename}_${uniqueId}.csv`;
    const outputPath = path.join(fallbackPath, filename);
    core.info(`Writing output CSV to fallback location: ${outputPath}`);
    try {
      fs.writeFileSync(outputPath, csvString, 'utf8');
      return outputPath;
    } catch (error) {
      core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to write output CSV to fallback location: ${outputPath}`);
    }
  }

  const uniqueId = Math.random().toString(36).substring(2, 8);
  const filename = `${baseFilename}_${uniqueId}.csv`;
  const outputPath = path.join(tempDir, filename);

  core.info(`Writing output CSV to: ${outputPath}`);
  try {
    fs.writeFileSync(outputPath, csvString, 'utf8');
    return outputPath;
  } catch (error) {
    core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
    throw new Error(`Failed to write output CSV: ${outputPath}`);
  }
}

export function writeOutputMarkdown(markdownString: string, baseFilename: string): string {
  // const tempDir = process.env.RUNNER_TEMP;
  // let outputPath: string;

  // if (!tempDir) {
  //   core.warning("RUNNER_TEMP environment variable not defined. Using current directory for Markdown output.");
  //   const fallbackPath = path.resolve('.');
  //   const uniqueId = Math.random().toString(36).substring(2, 8);
  //   const filename = `${baseFilename}_${uniqueId}.md`;
  //   outputPath = path.join(fallbackPath, filename);
  //   core.info(`Writing output Markdown to fallback location: ${outputPath}`);
  // } else {
  //   const uniqueId = Math.random().toString(36).substring(2, 8);
  //   const filename = `${baseFilename}_${uniqueId}.md`;
  //   outputPath = path.join(tempDir, filename);
  //   core.info(`Writing output Markdown to: ${outputPath}`);
  // }
  let outputDir = process.env.RUNNER_TEMP;
  const usingFallback = !!outputDir;
  if (!outputDir) {
    core.warning("RUNNER_TEMP environment variable not defined. Using current directory for Markdown output.");
    outputDir = path.resolve('.');
  }
  const uniqueId = Math.random().toString(36).substring(2, 8);
  const filename = `${baseFilename}_${uniqueId}.md`;
  const outputPath = path.join(outputDir, filename);
  core.info(`Writing output Markdown to${usingFallback ? ' fallback location' : ''}: ${outputPath}`);

  try {
    fs.writeFileSync(outputPath, markdownString, 'utf8');
    return outputPath;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    core.error(`Failed to write output Markdown file ${outputPath}: ${errorMessage}`);
    throw new Error(`Failed to write output Markdown to ${outputPath}: ${errorMessage}`);
  }
}

// Helper to clean cell data for Markdown table
function cleanCell(value: string | undefined | null, defaultValue = ''): string {
  return value?.trim().replace(/\\/g, '\\\\').replace(/\|/g, '\\|').replace(/`/g, '\\`').replace(/\r?\n|\r/g, ' ') || defaultValue;
}

export function generateMarkdown(
  data: CsvRow[],
  preFilterData?: CsvRow[]
): string {
  core.info(`Generating Markdown report for ${data.length} items.`);

  let markdown = `## Container Image Scan Results\n\n These results are generated by AWS Inspector, but have been filtered to reduce noise.\n\n`;

  // --- 1. Severity Summary Table ---
  markdown += `### Severity Summary\n\n`;

  const currentCounts = calculateSeverityCounts(data);
  const preFilterCounts = preFilterData ? calculateSeverityCounts(preFilterData) : null;

  const severities: (keyof SeverityCounts)[] = ['critical', 'high', 'medium', 'low', 'informational', 'undefined'];

  markdown += `| Severity      | Count | Pre-Filter Count |\n`;
  markdown += `|---------------|-------|------------------|\n`;

  let totalCurrentCount = 0;
  let totalPreFilterString = 'N/A';
  let tempTotalPreFilterNum = 0;

  if (preFilterCounts) {
    totalPreFilterString = '0';
  }

  for (const severity of severities) {
    const count = currentCounts[severity];
    totalCurrentCount += count;

    let preCountDisplay: string | number = 'N/A';
    if (preFilterCounts) {
      const preCount = preFilterCounts[severity];
      preCountDisplay = preCount;
      tempTotalPreFilterNum += preCount;
    }
    markdown += `| ${severity} | ${count} | ${preCountDisplay} |\n`;
  }

  if (preFilterCounts) {
    totalPreFilterString = tempTotalPreFilterNum.toString();
  }
  markdown += `| **Total** | **${totalCurrentCount}** | **${totalPreFilterString}** |\n\n`;

  // --- 2. Detailed Findings Table ---
  const detailedFindingsCount = data.length;
  markdown += `### Relevant Findings (${detailedFindingsCount})\n\n`;

  if (detailedFindingsCount === 0) {
    markdown += "No findings to display in this section.\n";
  } else {
    const headers = Object.keys(data[0] || {});
    const headerRow = `| ${headers.map(h => cleanCell(h)).join(' | ')} |`;
    const separatorRow = `| ${headers.map(() => '---').join(' | ')} |`;

    markdown += `${headerRow}\n`;
    markdown += `${separatorRow}\n`;

    const sortedDataForTable = [...data].sort((a, b) => {
      const scoreA = parseFloat(a['CVSS'] || '-1');
      const scoreB = parseFloat(b['CVSS'] || '-1');
      const validScoreA = isNaN(scoreA) ? -1 : scoreA;
      const validScoreB = isNaN(scoreB) ? -1 : scoreB;
      return validScoreB - validScoreA;
    });

    sortedDataForTable.forEach(row => {
      const cells = headers.map(header => cleanCell(row[header]));
      markdown += `| ${cells.join(' | ')} |\n`;
    });
  }

  return markdown;
}