import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import Papa from 'papaparse';
import { CsvRow, FilterResult, SeverityCounts, Thresholds } from './types';

const AWS_INSPECTOR_HEADER_COLUMNS = [ "ID","Severity","CVSS","Installed Package","Fixed Package","Path","EPSS","Exploit Available","Exploit Last Seen","CWEs"]

/**
 * Reads and parses a CSV file, validating required columns.
 * @param filePath Path to the CSV file.
 * @param requiredColumns Array of column names expected to exist.
 * @returns Array of row objects.
 * @throws Error if file not found or required column is missing.
 */
export function parseCsv(filePath: string): CsvRow[] {
    core.debug(`Attempting to read CSV file: ${filePath}`);
    if (!fs.existsSync(filePath)) {
        throw new Error(`CSV file not found at path: ${filePath}`);
    }
    const csvContent = fs.readFileSync(filePath, 'utf8');

    // Check if file content is empty
    if (!csvContent || csvContent.trim() === '') {
        core.info(`CSV file ${filePath} is empty.`);
        return [];
    }

    // Split content into lines, handling both \n and \r\n
    const lines = csvContent.split(/\r?\n/);

    // Check if there's at least a header line after removing the metadata line
    if (lines.length <= 3) {
        core.info(`CSV file ${filePath} contains only metadata line or is empty after splitting. No data to parse.`);
        return [];
    }


    // Skip the first two lines of metadata. Header is the third line
    const contentWithoutFirstLine = lines.slice(2).join('\n');

    const parseResult = Papa.parse<CsvRow>(contentWithoutFirstLine, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false, // Keep all as strings initially
    });

    if (parseResult.errors.length > 0) {
        core.warning(`CSV parsing encountered errors in ${filePath}:`);
        // Log only the first few errors to avoid excessive logging
        parseResult.errors.slice(0, 5).forEach(err => core.warning(`  - ${err.message} (Row: ${err.row})`));
        if (parseResult.errors.length > 5) {
            core.warning(`  ... and ${parseResult.errors.length - 5} more errors.`);
        }
        // Proceed even with errors if some data was parsed
    }

    if (!parseResult.data || parseResult.data.length === 0) {
        // This might be okay if the file is genuinely empty, log as info
        core.info(`CSV file ${filePath} is empty or contains no data rows.`);
        return [];
    }

    const headers = parseResult.meta.fields;
    if (!headers) {
        throw new Error(`Could not extract headers from CSV (after skipping first line): ${filePath}. Check file format.`);
    }
    core.info(`CSV Headers found in ${filePath} (after skipping first line): ${headers.join(', ')}`);


    core.debug(`Successfully parsed ${parseResult.data.length} data rows from ${filePath}.`);
    return parseResult.data;
}

function createFilteringKey(row: CsvRow): string | null {
    return `${row['ID']}`;
}

export function filterAndSeparate(
    primaryData: CsvRow[],
    comparisonData: CsvRow[]
): FilterResult {
    core.info(`Filtering ${primaryData.length} primary entries against ${comparisonData.length} comparison entries using assumed columns ('vuln_id', 'package_name').`);

    const comparisonKeys = new Set<string>();
    comparisonData.forEach(row => {
        const key = createFilteringKey(row); // Uses hardcoded names internally
        if (key !== null) {
            comparisonKeys.add(key);
        }
    });

    core.debug(`Created comparison key set with ${comparisonKeys.size} unique valid keys.`);

    const result: FilterResult = { filtered: [], removed: [] };
    primaryData.forEach(row => {
        const key = createFilteringKey(row);
        // If key is null (cannot identify uniquely) OR key is not in comparison set, keep it.
        if (key === null || !comparisonKeys.has(key)) {
            result.filtered.push(row);
        } else {
            // Key is valid AND present in comparison set, remove it.
            result.removed.push(row);
        }
    });

    core.debug(`Filtering comparison complete: ${result.filtered.length} findings remain, ${result.removed.length} removed.`);
    return result;
}

export function calculateSeverityCounts(data: CsvRow[]): SeverityCounts {
    const severityColumn = 'Severity'; // Assumed column name
    const counts: SeverityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFORMATIONAL: 0, UNDEFINED: 0 };

    for (const row of data) {
        // Standardize checks against uppercase
        const severity = (row[severityColumn]?.trim() || 'UNDEFINED').toLowerCase();
        switch (severity) {
            case 'critical': counts.CRITICAL++; break;
            case 'high': counts.HIGH++; break;
            case 'medium': counts.MEDIUM++; break;
            case 'low': counts.LOW++; break;
            case 'informational': counts.INFORMATIONAL++; break;
            default: counts.UNDEFINED++; break;
        }
    }
    core.info(`Calculated counts (assuming 'Severity' column): ${JSON.stringify(counts)}`);
    return counts;
}



// export function checkCountThresholds(counts: SeverityCounts, thresholds: Thresholds): boolean {
//     // ... (checkCountThresholds function remains the same as previous version) ...
//         let exceeded = false;
//     core.info('Checking vulnerability count thresholds...');

//     if (thresholds.critical >= 0 && counts.CRITICAL > thresholds.critical) {
//         core.error(`Threshold exceeded: ${counts.CRITICAL} CRITICAL vulnerabilities found (limit: ${thresholds.critical}).`);
//         exceeded = true;
//     } else if (thresholds.critical >= 0) {
//         core.info(`CRITICAL vulnerability count (${counts.CRITICAL}) within limit (${thresholds.critical}).`);
//     }

//     if (thresholds.high >= 0 && counts.HIGH > thresholds.high) {
//         core.error(`Threshold exceeded: ${counts.HIGH} HIGH vulnerabilities found (limit: ${thresholds.high}).`);
//         exceeded = true;
//     } else if (thresholds.high >= 0) {
//         core.info(`HIGH vulnerability count (${counts.HIGH}) within limit (${thresholds.high}).`);
//     }

//     if (thresholds.medium >= 0 && counts.MEDIUM > thresholds.medium) {
//         core.error(`Threshold exceeded: ${counts.MEDIUM} MEDIUM vulnerabilities found (limit: ${thresholds.medium}).`);
//         exceeded = true;
//     } else if (thresholds.medium >= 0) {
//         core.info(`MEDIUM vulnerability count (${counts.MEDIUM}) within limit (${thresholds.medium}).`);
//     }

//     if (thresholds.low >= 0 && counts.LOW > thresholds.low) {
//         core.error(`Threshold exceeded: ${counts.LOW} LOW vulnerabilities found (limit: ${thresholds.low}).`);
//         exceeded = true;
//     } else if (thresholds.low >= 0) {
//         core.info(`LOW vulnerability count (${counts.LOW}) within limit (${thresholds.low}).`);
//     }

//     if (!exceeded) {
//         core.info('All vulnerability counts are within defined thresholds.');
//     }
//     return exceeded;
// }


/**
 * Checks if calculated counts exceed the defined thresholds.
 */
export function checkCountThresholds(counts: SeverityCounts): boolean {
    let exceeded = false;
    core.info('Checking vulnerability count thresholds...');

    // Check each level only if its threshold is enabled (>= 0)
    if (counts.CRITICAL > 0 || counts.HIGH > 0) {
        core.warning(`Threshold exceeded: ${counts.CRITICAL} CRITICAL vulnerabilities found. ${counts.HIGH} HIGH vulnerabilities found`);
        exceeded = true;
    } 

    // Log final status
    if (!exceeded) {
        core.info('All vulnerability counts are within defined thresholds.');
    } else {
        core.info('One or more vulnerability count thresholds were exceeded.');
    }
    return exceeded;
}

/**
 * Checks if the value in the assumed 'fixed_ver' column indicates a fix is available.
 * Returns true if a seemingly valid fix version is present, false otherwise.
 */
export function isFixedVersionPresent(row: CsvRow): boolean {
    const fixedVer = row['Fixed Package'];
    if (!fixedVer) return false; // Handles null, undefined
    const trimmed = fixedVer.trim().toUpperCase();
    // Add any other known "no fix" indicators if necessary
    return trimmed !== '' && trimmed !== 'N/A' && trimmed !== 'NONE' && !trimmed.startsWith('NO_FIX');
}

/**
 * Generates a CSV string from an array of row objects.
 */
export function generateCsvString(data: CsvRow[]): string {
    if (data.length === 0) {
        return ''; // Return empty string if no data
    }
    try {
        const csvString = Papa.unparse(data, {
            header: true, // Include header row based on keys of first object
        });
        return csvString;
    } catch (error) {
        core.error(`Failed to generate CSV string: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error('CSV string generation failed.');
    }
}

/**
 * Writes data to a CSV file in the runner's temp directory.
 */
export function writeOutputCsv(csvString: string, baseFilename: string): string {
    const tempDir = process.env.RUNNER_TEMP;
    if (!tempDir) {
        // Fallback or error if runner temp is not available
        core.warning("RUNNER_TEMP environment variable not defined. Using current directory for output.");
        const fallbackPath = path.resolve('.'); // Use current directory
         // Ensure unique filename even in fallback
        const uniqueId = Math.random().toString(36).substring(2, 8);
        const filename = `${baseFilename}_${uniqueId}.csv`;
        const outputPath = path.join(fallbackPath, filename);
        core.info(`Writing output CSV to fallback location: ${outputPath}`);
         try {
            fs.writeFileSync(outputPath, csvString, 'utf8');
            return outputPath;
        } catch (error) {
            core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
            throw new Error(`Failed to write output CSV to fallback location: ${outputPath}`);
        }
    }

    // Ensure unique filename in runner temp
    const uniqueId = Math.random().toString(36).substring(2, 8);
    const filename = `${baseFilename}_${uniqueId}.csv`;
    const outputPath = path.join(tempDir, filename);

    core.info(`Writing output CSV to: ${outputPath}`);
    try {
        fs.writeFileSync(outputPath, csvString, 'utf8');
        return outputPath;
    } catch (error) {
        core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to write output CSV: ${outputPath}`);
    }
}

export function writeOutputMarkdown(markdownString: string, baseFilename: string): string {
    const tempDir = process.env.RUNNER_TEMP;
    let outputPath: string;

    if (!tempDir) {
        core.warning("RUNNER_TEMP environment variable not defined. Using current directory for Markdown output.");
        const fallbackPath = path.resolve('.'); // Use current directory
        const uniqueId = Math.random().toString(36).substring(2, 8);
        const filename = `${baseFilename}_${uniqueId}.md`; // Markdown extension
        outputPath = path.join(fallbackPath, filename);
        core.info(`Writing output Markdown to fallback location: ${outputPath}`);
    } else {
        // Generate unique filename in the runner's temp directory
        const uniqueId = Math.random().toString(36).substring(2, 8);
        const filename = `${baseFilename}_${uniqueId}.md`; // Markdown extension
        outputPath = path.join(tempDir, filename);
        core.info(`Writing output Markdown to: ${outputPath}`);
    }

    try {
        fs.writeFileSync(outputPath, markdownString, 'utf8');
        return outputPath;
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        core.error(`Failed to write output Markdown file ${outputPath}: ${errorMessage}`);
        throw new Error(`Failed to write output Markdown to ${outputPath}: ${errorMessage}`);
    }
}

// Helper to clean cell data for Markdown table
function cleanCell(value: string | undefined | null, defaultValue = ''): string {
    // Replace pipes (|), backticks (`), and newlines to avoid breaking Markdown table structure
    // Trim whitespace
    return value?.trim().replace(/\\/g, '\\\\').replace(/\|/g, '\\|').replace(/`/g, '\\`').replace(/\r?\n|\r/g, ' ') || defaultValue;
    //return value?.trim().replace(/\|/g, '\\|').replace(/`/g, '\\`').replace(/\r?\n|\r/g, ' ') || defaultValue;
}

// Helper to format PURL (uses assumed column names)
function formatPurl(pkgName: string | undefined | null, pkgVersion: string | undefined | null): string {
    const cleanPkg = cleanCell(pkgName);
    const cleanVer = cleanCell(pkgVersion);
    if (!cleanPkg || !cleanVer) return '';
    // Basic PURL format - Needs refinement for package types (npm, maven, etc.)
    // Consider adding another assumed column like 'package_manager' if available in CSV
    // For now, just represent as code block:
    return `\`${cleanPkg}@${cleanVer}\``;
}

export function generateMarkdown(
    data: CsvRow[],
    preFilterData?: CsvRow[]
): string {
    core.info(`Generating Markdown report for ${data.length} items.`);

    let markdown = `## Container Image Scan Results\n\n These results are generated by AWS Inspector, but may have been filtered to reduce noise.\n\n`;

    // --- 1. Severity Summary Table ---
    markdown += `### Severity Summary\n\n`;

    const currentCounts = calculateSeverityCounts(data);
    const preFilterCounts = preFilterData ? calculateSeverityCounts(preFilterData) : null;

    const severities: (keyof SeverityCounts)[] = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFORMATIONAL', 'UNDEFINED'];

    markdown += `| Severity      | Count | Pre-Filter Count |\n`;
    markdown += `|---------------|-------|------------------|\n`;

    let totalCurrentCount = 0;
    let totalPreFilterString = 'N/A';
    let tempTotalPreFilterNum = 0; // For summing if preFilterData actually exists

    if (preFilterCounts) {
        totalPreFilterString = '0'; // Will be populated by sum
    }

    for (const severity of severities) {
        const count = currentCounts[severity];
        totalCurrentCount += count;

        let preCountDisplay: string | number = 'N/A';
        if (preFilterCounts) {
            const preCount = preFilterCounts[severity];
            preCountDisplay = preCount;
            tempTotalPreFilterNum += preCount;
        }
        // No padding needed here, Markdown renderers handle alignment
        markdown += `| ${severity} | ${count} | ${preCountDisplay} |\n`;
    }

    if (preFilterCounts) {
        totalPreFilterString = tempTotalPreFilterNum.toString();
    }
    // Total Row for Summary Table
    markdown += `| **Total** | **${totalCurrentCount}** | **${totalPreFilterString}** |\n\n`;


    // --- 2. Detailed Findings Table ---
    const detailedFindingsCount = data.length;
    markdown += `### Detailed Findings (${detailedFindingsCount})\n\n`;

    if (detailedFindingsCount === 0) {
        markdown += "No findings to display in this section.\n";
    } else {
        // Get headers from the keys of the first row (if it exists) for the detailed table
        const headers = Object.keys(data[0] || {});
        const headerRow = `| ${headers.map(h => cleanCell(h)).join(' | ')} |`; // Clean headers too
        const separatorRow = `| ${headers.map(() => '---').join(' | ')} |`;

        markdown += `${headerRow}\n`;
        markdown += `${separatorRow}\n`;

        // Sort data by CVSS score (descending) - uses assumed 'cvss_score' if available
        // This sorting is for the detailed findings table
        const sortedDataForTable = [...data].sort((a, b) => {
            const scoreA = parseFloat(a['cvss_score'] || '-1'); // Assumes 'cvss_score' column
            const scoreB = parseFloat(b['cvss_score'] || '-1'); // Assumes 'cvss_score' column
            const validScoreA = isNaN(scoreA) ? -1 : scoreA;
            const validScoreB = isNaN(scoreB) ? -1 : scoreB;
            return validScoreB - validScoreA; // Descending sort
        });

        // Generate Data Rows - outputting all values in each row, in original column order
        sortedDataForTable.forEach(row => {
            // Use the dynamically obtained headers to ensure correct order
            const cells = headers.map(header => cleanCell(row[header]));
            markdown += `| ${cells.join(' | ')} |\n`;
        });
    }

    return markdown;
}

// Export necessary functions for main.ts
export { cleanCell, formatPurl };