import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import Papa from 'papaparse';
import {
  CsvRow, FilterResult, SeverityCounts, Thresholds,
} from './types';

export function parseCsv(filePath: string): CsvRow[] {
  core.debug(`Attempting to read CSV file: ${filePath}`);
  if (!fs.existsSync(filePath)) {
    throw new Error(`CSV file not found at path: ${filePath}`);
  }
  const csvContent = fs.readFileSync(filePath, 'utf8');

  // Check if file content is empty
  if (!csvContent || csvContent.trim() === '') {
    core.info(`CSV file ${filePath} is empty.`);
    return [];
  }

  // Split content into lines, handling both \n and \r\n
  const lines = csvContent.split(/\r?\n/);

  // Check if there's at least a header line after removing the metadata line
  if (lines.length <= 3) {
    core.info(`CSV file ${filePath} contains only metadata line or is empty after splitting. No data to parse.`);
    return [];
  }

  // Skip the first two lines of metadata. Header is the third line
  const contentWithoutFirstLine = lines.slice(2).join('\n');

  const parseResult = Papa.parse<CsvRow>(contentWithoutFirstLine, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: false, // Keep all as strings initially
  });

  if (parseResult.errors.length > 0) {
    core.warning(`CSV parsing encountered errors in ${filePath}:`);
    parseResult.errors.slice(0, 5).forEach((err) => core.warning(`  - ${err.message} (Row: ${err.row})`));
    if (parseResult.errors.length > 5) {
      core.warning(`  ... and ${parseResult.errors.length - 5} more errors.`);
    }
  }

  if (!parseResult.data || parseResult.data.length === 0) {
    core.info(`CSV file ${filePath} is empty or contains no data rows.`);
    return [];
  }

  const headers = parseResult.meta.fields;
  if (!headers) {
    throw new Error(`Could not extract headers from CSV (after skipping first line): ${filePath}. Check file format.`);
  }
  core.info(`CSV Headers found in ${filePath} (after skipping first line): ${headers.join(', ')}`);

  core.debug(`Successfully parsed ${parseResult.data.length} data rows from ${filePath}.`);
  return parseResult.data;
}

function createFilteringKey(row: CsvRow): string | null {
  return row.ID;
}

export function filterAndSeparate(
  primaryData: CsvRow[],
  comparisonData: CsvRow[],
): FilterResult {
  core.info(`Filtering ${primaryData.length} entries against ${comparisonData.length} comparison entries.`);

  const comparisonKeys = new Set<string>();
  comparisonData.forEach((row) => {
    const key = createFilteringKey(row);
    if (key !== null) {
      comparisonKeys.add(key);
    }
  });

  core.debug(`Created comparison key set with ${comparisonKeys.size} unique valid keys.`);

  const result: FilterResult = { filtered: [], removed: [] };
  primaryData.forEach((row) => {
    const key = createFilteringKey(row);
    if (key === null || !comparisonKeys.has(key)) {
      result.filtered.push(row);
    } else {
      result.removed.push(row);
    }
  });

  core.debug(`Filtering comparison complete: ${result.filtered.length} findings remain, ${result.removed.length} removed.`);
  return result;
}

export function calculateSeverityCounts(data: CsvRow[]): SeverityCounts {
  const severityColumn = 'Severity';
  const counts: SeverityCounts = {
    critical: 0, high: 0, medium: 0, low: 0, informational: 0, undefined: 0,
  };

  data.forEach((row) => {
    const severity = (row[severityColumn]?.trim()).toLowerCase();
    if (!(severity in counts)) {
      core.warning(`Unknown severity value '${severity}' found in row: ${JSON.stringify(row)}. Defaulting to 'undefined'.`);
      counts.undefined += 1;
    } else {
      counts[severity as keyof SeverityCounts] += 1;
    }
  });
  core.info(`Calculated counts (assuming 'Severity' column): ${JSON.stringify(counts)}`);
  return counts;
}

export function checkCountThresholds(counts: SeverityCounts, thresholds: Thresholds): boolean {
  core.info('Checking vulnerability count thresholds...');
  // using exceeded = exceeded || checkCountThreshold(...) to avoid setting exceeded to false once it is true
  let exceeded = checkCountThreshold(counts, thresholds.critical, 'critical');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.high, 'high');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.medium, 'medium');
  exceeded = exceeded || checkCountThreshold(counts, thresholds.low, 'low');
  if (!exceeded) {
    core.info('All vulnerability counts are within defined thresholds.');
  }
  return exceeded;
}
function checkCountThreshold(counts: SeverityCounts, threshold: number, severity: keyof SeverityCounts): boolean {
  if (threshold >= 0 && counts[severity] > threshold) {
    core.warning(`Threshold exceeded: ${counts[severity]} ${severity} vulnerabilities found (limit: ${threshold}).`);
    return true;
  } if (threshold >= 0) {
    core.info(`${severity.charAt(0).toUpperCase() + severity.slice(1)} (${counts[severity]}) vulns within limit (${threshold}).`);
  }
  return false;
}

export function isFixedVersionPresent(row: CsvRow): boolean {
  const fixedVer = row['Fixed Package'];
  if (!fixedVer) return false;
  const trimmed = fixedVer.trim().toUpperCase();
  return trimmed !== '' && trimmed !== 'N/A' && trimmed !== 'NONE' && !trimmed.startsWith('NO_FIX');
}

export function generateCsvString(data: CsvRow[]): string {
  if (data.length === 0) {
    return '';
  }
  try {
    const csvString = Papa.unparse(data, {
      header: true,
    });
    return csvString;
  } catch (error) {
    core.error(`Failed to generate CSV string: ${error instanceof Error ? error.message : String(error)}`);
    throw new Error('CSV string generation failed.');
  }
}

export function writeOutputCsv(csvString: string, baseFilename: string): string {
  const tempDir = process.env.RUNNER_TEMP;
  if (!tempDir) {
    core.warning('RUNNER_TEMP environment variable not defined. Using current directory for output.');
    const fallbackPath = path.resolve('.');
    const uniqueId = Math.random().toString(36).substring(2, 8);
    const filename = `${baseFilename}_${uniqueId}.csv`;
    const outputPath = path.join(fallbackPath, filename);
    core.info(`Writing output CSV to fallback location: ${outputPath}`);
    try {
      fs.writeFileSync(outputPath, csvString, 'utf8');
      return outputPath;
    } catch (error) {
      core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to write output CSV to fallback location: ${outputPath}`);
    }
  }

  const uniqueId = Math.random().toString(36).substring(2, 8);
  const filename = `${baseFilename}_${uniqueId}.csv`;
  const outputPath = path.join(tempDir, filename);

  core.info(`Writing output CSV to: ${outputPath}`);
  try {
    fs.writeFileSync(outputPath, csvString, 'utf8');
    return outputPath;
  } catch (error) {
    core.error(`Failed to write output CSV file ${outputPath}: ${error instanceof Error ? error.message : String(error)}`);
    throw new Error(`Failed to write output CSV: ${outputPath}`);
  }
}

export function writeOutputMarkdown(markdownString: string, baseFilename: string): string {
  let outputDir = process.env.RUNNER_TEMP;
  const usingFallback = !!outputDir;
  if (!outputDir) {
    core.warning('RUNNER_TEMP environment variable not defined. Using current directory for Markdown output.');
    outputDir = path.resolve('.');
  }
  const uniqueId = Math.random().toString(36).substring(2, 8);
  const filename = `${baseFilename}_${uniqueId}.md`;
  const outputPath = path.join(outputDir, filename);
  core.info(`Writing output Markdown to${usingFallback ? ' fallback location' : ''}: ${outputPath}`);

  try {
    fs.writeFileSync(outputPath, markdownString, 'utf8');
    return outputPath;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    core.error(`Failed to write output Markdown file ${outputPath}: ${errorMessage}`);
    throw new Error(`Failed to write output Markdown to ${outputPath}: ${errorMessage}`);
  }
}

// Helper to clean cell data for Markdown table
function cleanCell(value: string | undefined | null, defaultValue = ''): string {
  return value?.trim().replace(/\\/g, '\\\\').replace(/\|/g, '\\|').replace(/`/g, '\\`')
    .replace(/\r?\n|\r/g, ' ') || defaultValue;
}

export function generateMarkdown(
  data: CsvRow[],
  preFilterData?: CsvRow[],
): string {
  core.info(`Generating Markdown report for ${data.length} items.`);

  let markdown = `## Container Image Scan Results\n\n 
  These results generated by AWS Inspector, have been filtered to reduce noise.\n\n`;

  // --- 1. Severity Summary Table ---
  markdown += '### Severity Summary\n\n';

  const currentCounts = calculateSeverityCounts(data);
  const preFilterCounts = preFilterData ? calculateSeverityCounts(preFilterData) : null;

  const severities: (keyof SeverityCounts)[] = ['critical', 'high', 'medium', 'low', 'informational', 'undefined'];

  markdown += '| Severity      | Count | Pre-Filter Count |\n';
  markdown += '|---------------|-------|------------------|\n';

  let totalCurrentCount = 0;
  let totalPreFilterString = 'N/A';
  let tempTotalPreFilterNum = 0;

  if (preFilterCounts) {
    totalPreFilterString = '0';
  }

  severities.forEach((severity) => {
    const count = currentCounts[severity];
    totalCurrentCount += count;

    let preCountDisplay: string | number = 'N/A';
    if (preFilterCounts) {
      const preCount = preFilterCounts[severity];
      preCountDisplay = preCount;
      tempTotalPreFilterNum += preCount;
    }
    markdown += `| ${severity} | ${count} | ${preCountDisplay} |\n`;
  });

  if (preFilterCounts) {
    totalPreFilterString = tempTotalPreFilterNum.toString();
  }
  markdown += `| **Total** | **${totalCurrentCount}** | **${totalPreFilterString}** |\n\n`;

  // --- 2. Detailed Findings Table ---
  const detailedFindingsCount = data.length;
  markdown += `### Relevant Findings (${detailedFindingsCount})\n\n`;

  if (detailedFindingsCount === 0) {
    markdown += 'No findings to display in this section.\n';
  } else {
    const headers = Object.keys(data[0] || {});
    const headerRow = `| ${headers.map((h) => cleanCell(h)).join(' | ')} |`;
    const separatorRow = `| ${headers.map(() => '---').join(' | ')} |`;

    markdown += `${headerRow}\n`;
    markdown += `${separatorRow}\n`;

    const sortedDataForTable = [...data].sort((a, b) => {
      const scoreA = parseFloat(a.CVSS || '-1');
      const scoreB = parseFloat(b.CVSS || '-1');
      const validScoreA = Number.isNaN(scoreA) ? -1 : scoreA;
      const validScoreB = Number.isNaN(scoreB) ? -1 : scoreB;
      return validScoreB - validScoreA;
    });

    sortedDataForTable.forEach((row) => {
      const cells = headers.map((header) => cleanCell(row[header]));
      markdown += `| ${cells.join(' | ')} |\n`;
    });
  }

  return markdown;
}
